cache control
Cache-Control: no-store 和 Cache-Control: no-cache区别
● no-cache: 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后使用资源。no-cache does not mean "don't cache".  no-cache allows caches to store a response but requires them to revalidate it before reuse.
● no-store: 禁止缓存。Any caches of any kind (private or shared) should not store this response.

cookie
和cookie相关的请求头有两个：Set-Cookie，Cookie
请求头set-cookie不是简单的key: value型，value是一个以分号隔开的kv，
例如：Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; Secure;HttpOnly;
cookie中的属性有官方提供的，也可以自定义
path=/dir：将服务器上的文件目录作为Cookie的适用对象(若不指定则默认为文档所在的文件目录)
domain=域名：作为 Cookie 适用对象的域名 (若不指定则默认为创建 Cookie 的服务器的域名)
Secure：仅在 HTTPS 安全通信时才会发送 Cookie
HttpOnly：使 Cookie 不能被 JavaScript 脚本访问

HTTP四元组
指的是标识一个HTTP会话或连接的四个关键数据点：源IP地址、源端口、目的IP地址、目的端口
非对称加密
在非对称加密体系中，公钥和私钥都可以用于加密和解密，具体取决于你要实现的是加密还是验证。
1. 加密：确保只有私钥持有者能拿到明文
  ○ 加密：发送方使用接收方的公钥对数据进行加密。
  ○ 解密：接收方使用自己的私钥对数据进行解密。
2. 验证：确保报文来源的身份一定是私钥持有者
  ○ 签名：发送方使用自己的私钥对消息的哈希值或摘要进行加密，生成数字签名。
  ○ 验证：接收方使用发送方的公钥对数字签名进行解密，然后将解密后得到的哈希值与消息的哈希值比较，以验证签名。
HTTPS
HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用 SSL(Secure Socket Layer)和 TLS(Transport Layer Security)协议代替而已。
 通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和 SSL通信，再由SSL和TCP 通信了。SSL是独立于HTTP的协议，也可以给其他协议配合使用。

HTTPS加密过程：
1. 客户端向服务器发送 HTTPS 请求
2. 服务器将公钥证书发送给客户端
3. 客户端验证服务器的证书（下面细讲）
4. 如果验证通过，客户端生成一个用于会话的对称密钥
5. 客户端使用服务器的公钥对对称密钥进行加密，并将加密后的密钥发送给服务器
6. 服务器使用私钥对客户端发送的加密密钥进行解密，得到对称密钥
7. 服务器和客户端使用对称密钥进行加密和解密数据传输

客户端如何验证服务器证书：
1. 浏览器或操作系统中，通常预装了受信任的根证书颁发机构CA的公钥
2. 数字证书包括证书本身的数据和CA的数字签名。数字签名是证书数据的哈希值经过CA的私钥加密生成的。
3. 客户端使用CA公钥对服务器证书中的数字签名进行解密，这个值应该要是证书数据的哈希值。
4. 客户端用相同的哈希函数对证书数据计算哈希值，如果等于步骤3的到的哈希值，则证明证书的数据未经过篡改，证书数据中的服务器公钥可以拿来用。

SSE
SSE (Server-Sent Events) 是一种允许服务器主动向客户端发送事件通知的技术。据HTML5规范，SSE使用的Content-Type为text/event-stream，有如下特点：
1. 文本流式传输数据：使用纯文本格式（通常是UTF-8编码）来传输数据
2. 自动重连：如果连接中断会自动尝试重新连接到服务器。
3. 简单的协议：SSE协议相对简单，服务器可以发送简单的文本消息，每个消息前面带有“data: ”前缀，并以两个换行符结束。
4. 内置事件支持：客户端可以监听特定类型的事件，服务器端可以指定事件类型，客户端可以为这些事件指定回调函数。
5. 低延迟：SSE连接可以快速地将新事件推送给客户端，提供了实时通信的能力。
请求头：
GET /sse HTTP/1.1
Host: example.com
Accept: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
响应头：
HTTP/1.1 200 OK
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
报文格式：
● 不同消息之间通过空行分割
● 同一条消息由多个数据行组成，通过换行分割
● 每个数据行格式为字段名: 字段值。字段名有且有四个：event / id / retry / data
  ○ event：可自定义的事件类型，能用来做消息路由，选择性监听
  ○ id：消息id，可用于重连后确定从哪开始续传
  ○ retry：连接断开后隔多久重连
  ○ data：携带实际的消息数据。如果消息数据跨越多行，每一行都将以data:开头
data: {"username": "john", "time": "2pm"}
data: {"username": "sun", "time": "3pm"}
\n
id: 1
event: userupdate
data: {"username": "john", "time": "2pm"}
\n
:这是一条注释，会被浏览器忽略，可用于保持连接活跃，浏览器可能在一定时间内无数据交换后关闭连接
Websocket
WebSocket是一种在单个TCP连接上进行全双工通信的协议，和Http没关系，不安全，可被窃听，websocket secret（wss）是加密版
   SSE   Websocket
协议 HTTP  TCP
通信 只能从服务器向客户端推送数据 允许服务器和客户端之间实现双向通信
使用 轻量级，使用简单 相对复杂，需要借助库
连接数   HTTP/1 6个，HTTP/2 可协商（默认 100）  无限制
建立连接：
1. 通过http三次握手建立连接后，再把通信协议升级成websocket，利用了升级协议的请求头
客户端请求首部：
  a. Connection: Upgrade 提示协议升级
  b. Upgrade：websocket 升级的目标协议是webscoket
  c. Sec-WebSocket-Key：xxx 浏览器随机生成并经过base64加密后的字符串
服务端响应首部：
a. 101 Switching Protocols 已升级协议
b. Connection: Upgrade 升级后的协议是websocket
c. Sec-Websocket-Accept: HBMDBbZMiS59r3aAITpGtJ64Mfc=  对Set-websocket-key添加字符串并做SHA-1加密后做Base64编码，用于校验
连接建立完成：
1. 事件：websocket提供的事件分别有：
  a. onopen，握手完毕，可以开始通信
  b. onmessage：收到消息，消息可分为text和binary
  c. onerror：发生错误，一般可以在这里做重连的逻辑
  d. onclose：连接关闭
2. 方法：
  a. send：发送消息，需要websocket readyState为1（WEBSOCKET.OPEN）
  b. close：关闭连接
3. 状态：
  a. WEBSOCKET.CONNECTING
  b. WEBSOCKET.OPEN
  c. WEBSOCKET.CLOSING
  d. WEBSOCKET.CLOSED
数据帧：
websocket的数据传输基本单位是帧，每一帧的组成结构如下：

1. 标志位 ，占 4 位，每个标识占一位，第一位是FIN，最后一帧为1否则为0，只有一帧的消息也是1。第二三四位都为预留位。
2. 操作代码 ，占 4 位，表示帧的类型，其中 0~7 表示非控制帧，8~15 表示控制帧
  ○ 0 这是前面数据帧的续帧（为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片，结合FIN可以确定数据是否分成多个帧）；
  ○ 1 表示这是一个文本帧；
  ○ 2 表示这是一个二进制（ binary ）帧；
  ○ 3~7 保留，未来可以分配给新的非控制（ non-control ）帧；
  ○ 8 表示这是一个连接关闭（ close ）帧；
  ○ 9 表示这是一个 ping 帧；
  ○ 10 表示这是一个 pong 帧；
  ○ 11~15 保留，未来可以分配给新的控制（ control ）帧；
3. 掩码mask位：表示 承载数据（ payload data ）是否做掩码处理，1 表示掩码处理，0 表示不做掩码处理（客户端发的帧必须做掩码处理，主要出于避免网络中间件混淆和安全上的考虑）；
4. 数据长度（ payload len ），占 7 位，用来表示数据负载的长度（以字节为单位）；
  ○ 该字段小于 126 时，该字段直接表示数据长度，其后的扩展字段为空（ 0 字节），可表示 0~125 字节的数据；
  ○ 当该字段等于 126 时，数据长度由其后的扩展字段表示，这是扩展字段为 2 字节，可表示长度为 126~65535 字节的数据；
  ○ 当该字段等于 127 时，数据长度由其后的扩展字段表示，这时扩展字段为 8 字节，可表示长度为 216 到 264−1 字节的数据；
5. 扩展数据长度（ extended payload len ），占用 0 、2 或 8 字节，由前一个字段决定；
6. 掩码Key（ masking key ），数据帧开启掩码处理时（ MASK=1 ）才有，占用 4 个字节，用于掩码计算；
7. 承载数据（ payload data ），即数据帧承载的应用层数据；
攻击
XSS：Cross-Site Scripting，即跨站脚本攻击。
方式：攻击者将恶意脚本代码注入到正常用户会访问的页面中。当其他用户访问这个被注入的页面时，嵌入其中的恶意脚本会在用户的浏览器中执行。如：论坛留言，邮件链接等。
解法：用户的输入进行验证和转义，确保输入数据不会被解释为代码
CSRF：Cross-Site Request Forgery，即跨站请求伪造
方式：诱导已登录用户在浏览器中执行非预期的操作，来获得并利用用户在网站上的认证信息。如用户登陆网上银行后跳转到了恶意网站，使用户的浏览器在用户不知情的情况下发起恶意请求
解法：
  a. 使用Anti-CSRF Token：服务器向客户端发送一个唯一的、不可预测的令牌（CSRF令牌），在执行敏感操作时，客户端必须在请求中返回这个令牌。因为攻击者无法获取这个令牌，所以伪造的请求将会失败。
  b. 检查Referer头：服务器可以验证HTTP请求的Referer头，来检查请求是从合法的网站发起的还是恶意网站。
  c. 使用自定义请求头：由于浏览器的同源策略，恶意网站无法设置某些自定义请求头，服务器可以要求请求中必须包含某个自定义头。
网络协议分层



TCP三次握手

TCP报文结构

1. 序列号（Sequence Number）：TCP协议会对报文段中的每个字节进行顺序编号，用来解决包在网络中乱序的问题。
2. 确认号（Acknowledgment Number）：接收方下一次期望收到数据的序列号，用来解决丢包的问题。
3. 数据偏移（Data Offset）：表示TCP头部的长度，从而用于定位数据从哪里开始。
4. 保留（Reserved）：保留，设为零。
5. 控制位（Control Bits）/标志位（Flags）：标记位，用于控制TCP状态机
6. 窗口大小（Window Size）：这个字段用于流量控制，表示发送方允许的、未被确认的数据量。
7. 校验和（Checksum）：涵盖整个TCP报文段（包含伪头部、TCP头部和数据），用于传输过程的错误检测。
8. 紧急指针（Urgent Pointer）：当URG控制位被设置时，这个字段表明了紧急数据的结束位置。
9. 选项（Options）：该字段不是必须的，它可以被用来设置一些额外的参数，例如最大报文段生存时间（MSS），窗口扩大因子（Window Scale），选择性确认（SACK）等。
10. 填充（Padding）：为了使TCP头部的长度是32位字的整数倍，可能需要添加填充位。
11. 数据（Data）：这部分包含了传输的实际应用数据，数据部分的长度可以根据TCP头部中的数据偏移和实际传输的需求来确定。

TCP flag：
URG(Urgent，紧急标志)：数据包中有需要紧急处理的数据，应立即由TCP堆栈处理。
ACK(Acknowledgment，确认标志)：在连接建立和数据传输期间使用。用于确认数据包已经收到，也用于确认发起请求和拆除请求。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。
PSH(Push，推送标志)：这个位字段告诉应用程序立即发送数据。表示传入的数据应该直接传递给应用程序，而不是被缓存。PSH为0为普通情况，不需要立即传，可先进行缓存。
RST(Reset，重置标志)：重置TCP连接，表示TCP连接中出现异常必须强制断开连接，经常用它解决网络连接问题。
SYN(Synchronization，同步标志)：这个位标志用于发起一个连接，建立连接并设置初始序列号。
FIN(Finish，完成标志)：这个位字段表示TCP连接的结束，表示正在断开连接或关闭连接。当通信结束希望断开连接，通信双方的主机之间就可以相互交换FIN位置为1的TCP段。

三次握手中互换了什么？
源、目的端口号 / 序列号 / 滑动窗口

如果仅仅是互换信息两次不就够了，为啥还需要三次握手？
主要是防止旧的重复连接初始化造成混乱
假定客户端进行了第一次握手seq = 20，然后宕机了，注意不是超时重传，超时重传的seq会是一样的。机器恢复后又发送了第一次握手seq=30，服务端先收到了seq=20的连接请求立即建立了链接，这个连接就被浪费掉了。
如果是三次握手，那么客户端在收到第三次握手时就能通过ack发现这是一个旧的握手请求，可以立即终止连接。

其次是确保双方的收发数据没问题。
第一次客户端发送报文后，服务端确定了客户端发送能力OK
第二次服务商响应后，客户端知道了服务商的发送和接收都OK
但是服务商不知道客户端的接收是否OK，因此还需要第三次客户端再次发送报文，服务端就可以确认了

序列号
客户端和服务端各自有各自的序列号，作用是：
● 接收方用于去除重复的数据
● 接收方可以根据数据包的序列号按序接收
● 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）
初始化序列号ISN（Initial Sequence Number）是如何产生的
起始 ISN 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。
RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost, localport, remotehost, remoteport)。
● M 是一个计时器，这个计时器每隔 4 微秒加 1。
● F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。
可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。
序列号回绕 sequence wrap around
同一个TCP连接的序列号数字不可能无限的递增，迟早会发生回绕为初始值的情况，但是TCP数据包又依赖序列号进行去重排序，所以tcp默认开启了tcp时间戳。
防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，避免了历史报文被接收的问题。

三次握手为什么都是+1
SYN报文和FIN报文从技术的角度看，并没有数据部分，但是TCP协议规定这两个类型的报文都要消耗1序列号
所以确认号是对方的序列号+1



TCP怎么确保数据的可靠传输
1. 序列号和应答机制
TCP的报文段中，每个字节都有各自的序列号，并将报文段的第一个序号放入头部的序列号中，方便接收方接收到后按照顺序重组。假定发送方一次性发送了10字节的数据，接收方在确认收到数据后，会将上次的确认号 + 10 + 1作为确认号相应给发送方，意思是期望下次接收到数据序列号的意思。


数据如何到达下一层协议？
